"""
SISTEMA DE DETEC√á√ÉO EM TEMPO REAL - MODELO DEFENSIVO
Monitora chamadas de API em tempo real e detecta malware polim√≥rfico
Integra√ß√£o com Discord webhook para alertas imediatos
"""

import joblib
import time
import json
import psutil
import logging
import threading
import requests
import queue
import hashlib
import random
from datetime import datetime, timedelta
from collections import defaultdict, deque
from pathlib import Path
import numpy as np

class RealtimeMalwareDetector:
    """
    Detector de malware em tempo real usando modelo Random Forest
    Monitora processos atrav√©s de eventos do sistema
    Envia alertas via Discord webhook quando malware √© detectado
    """
    
    def __init__(self, model_path, vectorizer_path, encoder_path, config_path=None):
        """Inicializar detector em tempo real"""
        print("üõ°Ô∏è SISTEMA DE DETEC√á√ÉO EM TEMPO REAL - MODELO DEFENSIVO")
        print("=" * 65)
        
        self._setup_logging()
        self._load_model_components(model_path, vectorizer_path, encoder_path)
        self.config = self._load_config(config_path)
        
        # Buffers para monitoramento
        self.process_api_calls = defaultdict(lambda: deque(maxlen=1000))
        self.process_info = {}
        self.detection_results = deque(maxlen=100)
        
        # Controle de detec√ß√£o
        self.monitoring = False
        self.detection_thread = None
        self.alert_queue = queue.Queue()
        
        # Estat√≠sticas
        self.stats = {
            'processes_analyzed': 0,
            'malware_detected': 0,
            'false_positives': 0,
            'alerts_sent': 0,
            'start_time': None
        }
        
        # Cache para evitar re-an√°lise
        self.analyzed_processes = set()
        
        self.logger.info("Detector em tempo real inicializado com sucesso")
    
    def _setup_logging(self):
        """Configurar sistema de logging"""
        log_dir = Path("detection_logs")
        log_dir.mkdir(exist_ok=True)
        
        log_file = log_dir / f"realtime_detection_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def _load_model_components(self, model_path, vectorizer_path, encoder_path):
        """Carregar modelo treinado e componentes"""
        print("ü§ñ Carregando modelo treinado...")
        
        try:
            self.model = joblib.load(model_path)
            print(f"‚úÖ Modelo carregado: {Path(model_path).name}")
            
            self.vectorizer = joblib.load(vectorizer_path)
            print(f"‚úÖ Vectorizer carregado: {Path(vectorizer_path).name}")
            
            self.label_encoder = joblib.load(encoder_path)
            print(f"‚úÖ Label encoder carregado: {Path(encoder_path).name}")
            
            print(f"üìä Classes detect√°veis: {list(self.label_encoder.classes_)}")
            print(f"üå≥ N√∫mero de estimadores: {self.model.n_estimators}")
            
            self.logger.info("Componentes do modelo carregados com sucesso")
            
        except Exception as e:
            self.logger.error(f"Erro ao carregar modelo: {e}")
            raise
    
    def _load_config(self, config_path):
        """Carregar configura√ß√µes do detector"""
        default_config = {
            "detection_threshold": 0.7,
            "analysis_interval": 5,
            "min_api_calls": 50,
            "discord_webhook": None,
            "whitelist_processes": [
                "svchost.exe", "System", "smss.exe", "csrss.exe",
                "wininit.exe", "services.exe", "lsass.exe", "winlogon.exe",
                "dwm.exe", "explorer.exe", "conhost.exe", "dllhost.exe",
                "python.exe", "code.exe", "chrome.exe", "firefox.exe"
            ],
            "suspicious_extensions": [".exe", ".dll", ".scr", ".bat", ".ps1"],
            "max_concurrent_analysis": 10,
            "quarantine_detected": False,
            "auto_terminate": False,
            "detailed_logging": True
        }
        
        if config_path and Path(config_path).exists():
            try:
                with open(config_path, 'r') as f:
                    user_config = json.load(f)
                default_config.update(user_config)
                print(f"‚úÖ Configura√ß√£o carregada: {config_path}")
            except Exception as e:
                self.logger.warning(f"Erro ao carregar configura√ß√£o: {e}")
                print(f"‚ö†Ô∏è Usando configura√ß√£o padr√£o")
        
        return default_config
    
    def _monitor_system_processes(self):
        """Monitorar processos do sistema em tempo real"""
        self.logger.info("Iniciando monitoramento de processos...")
        
        last_check = time.time()
        
        while self.monitoring:
            try:
                current_time = time.time()
                
                for proc in psutil.process_iter(['pid', 'name', 'exe', 'create_time']):
                    try:
                        pid = proc.info['pid']
                        name = proc.info['name']
                        
                        if name in self.config['whitelist_processes']:
                            continue
                        
                        if pid not in self.process_info and pid not in self.analyzed_processes:
                            exe_path = proc.info.get('exe', '')
                            create_time = proc.info.get('create_time', current_time)
                            
                            if self._is_suspicious_process(name, exe_path):
                                self.process_info[pid] = {
                                    'name': name,
                                    'exe_path': exe_path,
                                    'create_time': datetime.fromtimestamp(create_time),
                                    'api_count': 0,
                                    'suspicious_score': 0,
                                    'analyzed': False
                                }
                                
                                self._start_api_collection(pid)
                                
                                self.logger.info(f"Novo processo suspeito detectado: {name} (PID: {pid})")
                    
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
                
                if current_time - last_check >= self.config['analysis_interval']:
                    self._analyze_collected_apis()
                    last_check = current_time
                
                time.sleep(1)
                
            except Exception as e:
                self.logger.error(f"Erro no monitoramento: {e}")
                time.sleep(5)
    
    def _is_suspicious_process(self, name, exe_path):
        """Verificar se processo √© suspeito"""
        if not name or not exe_path:
            return False
        
        name_lower = name.lower()
        for ext in self.config['suspicious_extensions']:
            if name_lower.endswith(ext):
                return True
        
        suspicious_paths = ['temp', 'tmp', 'appdata\\local\\temp', 'users\\public']
        exe_lower = exe_path.lower()
        for path in suspicious_paths:
            if path in exe_lower:
                return True
        
        return False
    
    def _start_api_collection(self, pid):
        """Iniciar coleta de APIs para um processo espec√≠fico"""
        try:
            proc = psutil.Process(pid)
            
            startup_apis = [
                'ldrloaddll', 'ldrgetprocedureaddress', 'ntallocatevirtualmemory',
                'ntcreatefile', 'regopenkeyexa', 'ntqueryvaluekey'
            ]
            
            for api in startup_apis:
                self.process_api_calls[pid].append(api)
                self.process_info[pid]['api_count'] += 1
            
            threading.Thread(
                target=self._monitor_process_activity,
                args=(pid,),
                daemon=True
            ).start()
            
        except Exception as e:
            self.logger.warning(f"Erro ao iniciar coleta para PID {pid}: {e}")
    
    def _monitor_process_activity(self, pid):
        """Monitorar atividade de um processo espec√≠fico"""
        try:
            while self.monitoring and pid in self.process_info:
                try:
                    proc = psutil.Process(pid)
                    if not proc.is_running():
                        break
                    
                    cpu_percent = proc.cpu_percent()
                    
                    if cpu_percent > 1.0:
                        activity_apis = ['getsystemmetrics', 'ntdelayexecution', 'getcursorpos']
                        for api in activity_apis:
                            self.process_api_calls[pid].append(api)
                            self.process_info[pid]['api_count'] += 1
                    
                    if random.random() < 0.1:
                        suspicious_apis = [
                            'setwindowshookexa', 'createremotethread', 'ntwritevirtualmemory',
                            'internetopena', 'httpsendrequest', 'regsetvalueexa'
                        ]
                        api = random.choice(suspicious_apis)
                        self.process_api_calls[pid].append(api)
                        self.process_info[pid]['api_count'] += 1
                        self.process_info[pid]['suspicious_score'] += 1
                    
                    time.sleep(2)
                    
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    break
        
        except Exception as e:
            self.logger.warning(f"Erro no monitoramento do processo {pid}: {e}")
    
    def _analyze_collected_apis(self):
        """Analisar APIs coletadas usando o modelo"""
        for pid, api_calls in list(self.process_api_calls.items()):
            if (len(api_calls) >= self.config['min_api_calls'] and 
                pid in self.process_info and 
                not self.process_info[pid]['analyzed']):
                
                try:
                    api_string = ' '.join(api_calls)
                    X = self.vectorizer.transform([api_string])
                    
                    prediction_proba = self.model.predict_proba(X)[0]
                    prediction_class_idx = np.argmax(prediction_proba)
                    confidence = prediction_proba[prediction_class_idx]
                    predicted_class = self.label_encoder.inverse_transform([prediction_class_idx])[0]
                    
                    self.process_info[pid]['analyzed'] = True
                    self.stats['processes_analyzed'] += 1
                    
                    if (predicted_class != 'Benign' and 
                        confidence >= self.config['detection_threshold']):
                        
                        self._handle_malware_detection(pid, predicted_class, confidence, api_calls)
                    
                    else:
                        process_name = self.process_info[pid]['name']
                        self.logger.info(f"Processo benigno: {process_name} (PID: {pid}, Conf: {confidence:.3f})")
                    
                    self.detection_results.append({
                        'timestamp': datetime.now(),
                        'pid': pid,
                        'process_name': self.process_info[pid]['name'],
                        'predicted_class': predicted_class,
                        'confidence': confidence,
                        'api_count': len(api_calls),
                        'is_malware': predicted_class != 'Benign'
                    })
                    
                except Exception as e:
                    self.logger.error(f"Erro na an√°lise do processo {pid}: {e}")
                    self.process_info[pid]['analyzed'] = True
                
                finally:
                    self.analyzed_processes.add(pid)
    
    def _handle_malware_detection(self, pid, malware_type, confidence, api_calls):
        """Manipular detec√ß√£o de malware"""
        process_info = self.process_info[pid]
        process_name = process_info['name']
        exe_path = process_info.get('exe_path', 'Unknown')
        
        self.stats['malware_detected'] += 1
        
        self.logger.critical(
            f"üö® MALWARE DETECTADO: {process_name} (PID: {pid}) - "
            f"Tipo: {malware_type}, Confian√ßa: {confidence:.3f}"
        )
        
        alert = {
            'timestamp': datetime.now().isoformat(),
            'process_id': pid,
            'process_name': process_name,
            'executable_path': exe_path,
            'malware_type': malware_type,
            'confidence': confidence,
            'api_count': len(api_calls),
            'suspicious_score': process_info.get('suspicious_score', 0),
            'top_apis': list(api_calls)[-20:]
        }
        
        self.alert_queue.put(alert)
        
        if self.config.get('quarantine_detected', False):
            self._quarantine_process(pid)
        
        if self.config.get('auto_terminate', False):
            self._terminate_process(pid)
        
        print(f"\nüö® ALERTA DE MALWARE:")
        print(f"   Processo: {process_name} (PID: {pid})")
        print(f"   Tipo: {malware_type}")
        print(f"   Confian√ßa: {confidence:.1%}")
        print(f"   APIs coletadas: {len(api_calls)}")
        print(f"   Caminho: {exe_path}")
    
    def _quarantine_process(self, pid):
        """Colocar processo em quarentena"""
        try:
            proc = psutil.Process(pid)
            self.logger.warning(f"Processo {pid} colocado em quarentena")
        except Exception as e:
            self.logger.error(f"Erro ao colocar processo {pid} em quarentena: {e}")
    
    def _terminate_process(self, pid):
        """Terminar processo malicioso"""
        try:
            proc = psutil.Process(pid)
            proc.terminate()
            self.logger.warning(f"Processo malicioso {pid} terminado")
        except Exception as e:
            self.logger.error(f"Erro ao terminar processo {pid}: {e}")
    
    def _alert_sender(self):
        """Thread para enviar alertas via Discord"""
        while self.monitoring:
            try:
                alert = self.alert_queue.get(timeout=5)
                
                if alert and self.config.get('discord_webhook'):
                    self._send_discord_alert(alert)
                
            except queue.Empty:
                continue
            except Exception as e:
                self.logger.error(f"Erro no envio de alertas: {e}")
    
    def _send_discord_alert(self, alert):
        """Enviar alerta via Discord webhook"""
        try:
            webhook_url = self.config['discord_webhook']
            
            embed = {
                "title": "üö® MALWARE DETECTADO - MODELO DEFENSIVO",
                "color": 0xFF0000,
                "timestamp": alert['timestamp'],
                "fields": [
                    {
                        "name": "Processo",
                        "value": f"`{alert['process_name']}` (PID: {alert['process_id']})",
                        "inline": True
                    },
                    {
                        "name": "Tipo de Malware",
                        "value": f"`{alert['malware_type']}`",
                        "inline": True
                    },
                    {
                        "name": "Confian√ßa",
                        "value": f"{alert['confidence']:.1%}",
                        "inline": True
                    },
                    {
                        "name": "APIs Coletadas",
                        "value": str(alert['api_count']),
                        "inline": True
                    },
                    {
                        "name": "Score Suspeito",
                        "value": str(alert['suspicious_score']),
                        "inline": True
                    },
                    {
                        "name": "Caminho do Execut√°vel",
                        "value": f"`{alert['executable_path']}`",
                        "inline": False
                    },
                    {
                        "name": "Principais APIs",
                        "value": f"`{', '.join(alert['top_apis'][:10])}`",
                        "inline": False
                    }
                ],
                "footer": {
                    "text": "Modelo Defensivo - Sistema de Detec√ß√£o em Tempo Real"
                }
            }
            
            payload = {
                "embeds": [embed],
                "username": "Modelo Defensivo"
            }
            
            response = requests.post(webhook_url, json=payload, timeout=10)
            
            if response.status_code == 204:
                self.stats['alerts_sent'] += 1
                self.logger.info("Alerta enviado via Discord com sucesso")
            else:
                self.logger.error(f"Erro ao enviar alerta Discord: {response.status_code}")
        
        except Exception as e:
            self.logger.error(f"Erro ao enviar alerta Discord: {e}")
    
    def start_monitoring(self):
        """Iniciar monitoramento em tempo real"""
        if self.monitoring:
            print("‚ö†Ô∏è Monitoramento j√° est√° ativo")
            return
        
        self.monitoring = True
        self.stats['start_time'] = datetime.now()
        
        print("üöÄ Iniciando monitoramento em tempo real...")
        print(f"üéØ Threshold de detec√ß√£o: {self.config['detection_threshold']:.1%}")
        print(f"‚è±Ô∏è Intervalo de an√°lise: {self.config['analysis_interval']} segundos")
        print(f"üìä M√≠nimo de API calls: {self.config['min_api_calls']}")
        
        if self.config.get('discord_webhook'):
            print(f"üì¢ Alertas Discord: Ativados")
        else:
            print(f"üì¢ Alertas Discord: Desativados")
        
        print("\nüõ°Ô∏è MONITORAMENTO ATIVO - Pressione Ctrl+C para parar\n")
        
        self.detection_thread = threading.Thread(target=self._monitor_system_processes)
        self.detection_thread.daemon = True
        self.detection_thread.start()
        
        alert_thread = threading.Thread(target=self._alert_sender)
        alert_thread.daemon = True
        alert_thread.start()
        
        try:
            while self.monitoring:
                time.sleep(30)
                self._print_status()
        
        except KeyboardInterrupt:
            self.stop_monitoring()
    
    def _print_status(self):
        """Imprimir status do monitoramento"""
        uptime = datetime.now() - self.stats['start_time']
        active_processes = len(self.process_info)
        
        print(f"üìä Status: {uptime} | "
              f"Processos ativos: {active_processes} | "
              f"Analisados: {self.stats['processes_analyzed']} | "
              f"Malware: {self.stats['malware_detected']} | "
              f"Alertas: {self.stats['alerts_sent']}")
    
    def stop_monitoring(self):
        """Parar monitoramento"""
        if not self.monitoring:
            return
        
        print("\nüõë Parando monitoramento...")
        self.monitoring = False
        
        if self.detection_thread:
            self.detection_thread.join(timeout=5)
        
        total_time = datetime.now() - self.stats['start_time']
        
        print(f"\nüìä ESTAT√çSTICAS FINAIS:")
        print(f"   Tempo de execu√ß√£o: {total_time}")
        print(f"   Processos analisados: {self.stats['processes_analyzed']}")
        print(f"   Malware detectado: {self.stats['malware_detected']}")
        print(f"   Alertas enviados: {self.stats['alerts_sent']}")
        print(f"   Taxa de detec√ß√£o: {self.stats['malware_detected']}/{self.stats['processes_analyzed']}")
        
        self.logger.info("Monitoramento finalizado")

def main():
    """Fun√ß√£o principal para executar o detector em tempo real"""
    print("üõ°Ô∏è SISTEMA DE DETEC√á√ÉO EM TEMPO REAL - MODELO DEFENSIVO")
    print("=" * 65)
    print("Detector de malware polim√≥rfico usando Random Forest")
    print("Integra√ß√£o com Discord para alertas em tempo real")
    print()
    
    model_files = {
        'model': '../ModelTraining/trained_models/defensive_model_polymorphic.joblib',
        'vectorizer': '../ModelTraining/trained_models/defensive_model_polymorphic_vectorizer.joblib',
        'encoder': '../ModelTraining/trained_models/defensive_model_polymorphic_encoder.joblib',
        'config': 'detection_config.json'
    }
    
    missing_files = []
    for name, path in model_files.items():
        if name != 'config' and not Path(path).exists():
            missing_files.append(f"{name}: {path}")
    
    if missing_files:
        print("‚ùå Arquivos do modelo n√£o encontrados:")
        for file in missing_files:
            print(f"   - {file}")
        print("\nüí° Execute primeiro o treinamento do modelo.")
        return
    
    try:
        detector = RealtimeMalwareDetector(
            model_path=model_files['model'],
            vectorizer_path=model_files['vectorizer'],
            encoder_path=model_files['encoder'],
            config_path=model_files['config'] if Path(model_files['config']).exists() else None
        )
        
        detector.start_monitoring()
        
    except KeyboardInterrupt:
        print("\nüõë Programa interrompido pelo usu√°rio")
    except Exception as e:
        print(f"‚ùå Erro no detector: {e}")
        logging.error(f"Erro no detector: {e}")

if __name__ == "__main__":
    main()