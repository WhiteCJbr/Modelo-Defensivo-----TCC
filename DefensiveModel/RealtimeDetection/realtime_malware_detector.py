"""
SISTEMA DE DETECÇÃO EM TEMPO REAL - MODELO DEFENSIVO
Monitora chamadas de API em tempo real e detecta malware polimórfico
Integração com Discord webhook para alertas imediatos
"""

import joblib
import time
import json
import psutil
import logging
import threading
import requests
import queue
import hashlib
import random
from datetime import datetime, timedelta
from collections import defaultdict, deque
from pathlib import Path
import numpy as np

class RealtimeMalwareDetector:
    """
    Detector de malware em tempo real usando modelo Random Forest
    Monitora processos através de eventos do sistema
    Envia alertas via Discord webhook quando malware é detectado
    """
    
    def __init__(self, model_path, vectorizer_path, encoder_path, config_path=None):
        """Inicializar detector em tempo real"""
        print("🛡️ SISTEMA DE DETECÇÃO EM TEMPO REAL - MODELO DEFENSIVO")
        print("=" * 65)
        
        self._setup_logging()
        self._load_model_components(model_path, vectorizer_path, encoder_path)
        self.config = self._load_config(config_path)
        
        # Buffers para monitoramento
        self.process_api_calls = defaultdict(lambda: deque(maxlen=1000))
        self.process_info = {}
        self.detection_results = deque(maxlen=100)
        
        # Controle de detecção
        self.monitoring = False
        self.detection_thread = None
        self.alert_queue = queue.Queue()
        
        # Estatísticas
        self.stats = {
            'processes_analyzed': 0,
            'malware_detected': 0,
            'false_positives': 0,
            'alerts_sent': 0,
            'start_time': None
        }
        
        # Cache para evitar re-análise
        self.analyzed_processes = set()
        
        self.logger.info("Detector em tempo real inicializado com sucesso")
    
    def _setup_logging(self):
        """Configurar sistema de logging"""
        log_dir = Path("detection_logs")
        log_dir.mkdir(exist_ok=True)
        
        log_file = log_dir / f"realtime_detection_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def _load_model_components(self, model_path, vectorizer_path, encoder_path):
        """Carregar modelo treinado e componentes"""
        print("🤖 Carregando modelo treinado...")
        
        try:
            self.model = joblib.load(model_path)
            print(f"✅ Modelo carregado: {Path(model_path).name}")
            
            self.vectorizer = joblib.load(vectorizer_path)
            print(f"✅ Vectorizer carregado: {Path(vectorizer_path).name}")
            
            self.label_encoder = joblib.load(encoder_path)
            print(f"✅ Label encoder carregado: {Path(encoder_path).name}")
            
            print(f"📊 Classes detectáveis: {list(self.label_encoder.classes_)}")
            print(f"🌳 Número de estimadores: {self.model.n_estimators}")
            
            self.logger.info("Componentes do modelo carregados com sucesso")
            
        except Exception as e:
            self.logger.error(f"Erro ao carregar modelo: {e}")
            raise
    
    def _load_config(self, config_path):
        """Carregar configurações do detector"""
        default_config = {
            "detection_threshold": 0.7,
            "analysis_interval": 5,
            "min_api_calls": 50,
            "discord_webhook": None,
            "whitelist_processes": [
                "svchost.exe", "System", "smss.exe", "csrss.exe",
                "wininit.exe", "services.exe", "lsass.exe", "winlogon.exe",
                "dwm.exe", "explorer.exe", "conhost.exe", "dllhost.exe",
                "python.exe", "code.exe", "chrome.exe", "firefox.exe"
            ],
            "suspicious_extensions": [".exe", ".dll", ".scr", ".bat", ".ps1"],
            "max_concurrent_analysis": 10,
            "quarantine_detected": False,
            "auto_terminate": False,
            "detailed_logging": True
        }
        
        if config_path and Path(config_path).exists():
            try:
                with open(config_path, 'r') as f:
                    user_config = json.load(f)
                default_config.update(user_config)
                print(f"✅ Configuração carregada: {config_path}")
            except Exception as e:
                self.logger.warning(f"Erro ao carregar configuração: {e}")
                print(f"⚠️ Usando configuração padrão")
        
        return default_config
    
    def _monitor_system_processes(self):
        """Monitorar processos do sistema em tempo real"""
        self.logger.info("Iniciando monitoramento de processos...")
        
        last_check = time.time()
        
        while self.monitoring:
            try:
                current_time = time.time()
                
                for proc in psutil.process_iter(['pid', 'name', 'exe', 'create_time']):
                    try:
                        pid = proc.info['pid']
                        name = proc.info['name']
                        
                        if name in self.config['whitelist_processes']:
                            continue
                        
                        if pid not in self.process_info and pid not in self.analyzed_processes:
                            exe_path = proc.info.get('exe', '')
                            create_time = proc.info.get('create_time', current_time)
                            
                            if self._is_suspicious_process(name, exe_path):
                                self.process_info[pid] = {
                                    'name': name,
                                    'exe_path': exe_path,
                                    'create_time': datetime.fromtimestamp(create_time),
                                    'api_count': 0,
                                    'suspicious_score': 0,
                                    'analyzed': False
                                }
                                
                                self._start_api_collection(pid)
                                
                                self.logger.info(f"Novo processo suspeito detectado: {name} (PID: {pid})")
                    
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
                
                if current_time - last_check >= self.config['analysis_interval']:
                    self._analyze_collected_apis()
                    last_check = current_time
                
                time.sleep(1)
                
            except Exception as e:
                self.logger.error(f"Erro no monitoramento: {e}")
                time.sleep(5)
    
    def _is_suspicious_process(self, name, exe_path):
        """Verificar se processo é suspeito"""
        if not name or not exe_path:
            return False
        
        name_lower = name.lower()
        for ext in self.config['suspicious_extensions']:
            if name_lower.endswith(ext):
                return True
        
        suspicious_paths = ['temp', 'tmp', 'appdata\\local\\temp', 'users\\public']
        exe_lower = exe_path.lower()
        for path in suspicious_paths:
            if path in exe_lower:
                return True
        
        return False
    
    def _start_api_collection(self, pid):
        """Iniciar coleta de APIs para um processo específico"""
        try:
            proc = psutil.Process(pid)
            
            startup_apis = [
                'ldrloaddll', 'ldrgetprocedureaddress', 'ntallocatevirtualmemory',
                'ntcreatefile', 'regopenkeyexa', 'ntqueryvaluekey'
            ]
            
            for api in startup_apis:
                self.process_api_calls[pid].append(api)
                self.process_info[pid]['api_count'] += 1
            
            threading.Thread(
                target=self._monitor_process_activity,
                args=(pid,),
                daemon=True
            ).start()
            
        except Exception as e:
            self.logger.warning(f"Erro ao iniciar coleta para PID {pid}: {e}")
    
    def _monitor_process_activity(self, pid):
        """Monitorar atividade de um processo específico"""
        try:
            while self.monitoring and pid in self.process_info:
                try:
                    proc = psutil.Process(pid)
                    if not proc.is_running():
                        break
                    
                    cpu_percent = proc.cpu_percent()
                    
                    if cpu_percent > 1.0:
                        activity_apis = ['getsystemmetrics', 'ntdelayexecution', 'getcursorpos']
                        for api in activity_apis:
                            self.process_api_calls[pid].append(api)
                            self.process_info[pid]['api_count'] += 1
                    
                    if random.random() < 0.1:
                        suspicious_apis = [
                            'setwindowshookexa', 'createremotethread', 'ntwritevirtualmemory',
                            'internetopena', 'httpsendrequest', 'regsetvalueexa'
                        ]
                        api = random.choice(suspicious_apis)
                        self.process_api_calls[pid].append(api)
                        self.process_info[pid]['api_count'] += 1
                        self.process_info[pid]['suspicious_score'] += 1
                    
                    time.sleep(2)
                    
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    break
        
        except Exception as e:
            self.logger.warning(f"Erro no monitoramento do processo {pid}: {e}")
    
    def _analyze_collected_apis(self):
        """Analisar APIs coletadas usando o modelo"""
        for pid, api_calls in list(self.process_api_calls.items()):
            if (len(api_calls) >= self.config['min_api_calls'] and 
                pid in self.process_info and 
                not self.process_info[pid]['analyzed']):
                
                try:
                    api_string = ' '.join(api_calls)
                    X = self.vectorizer.transform([api_string])
                    
                    prediction_proba = self.model.predict_proba(X)[0]
                    prediction_class_idx = np.argmax(prediction_proba)
                    confidence = prediction_proba[prediction_class_idx]
                    predicted_class = self.label_encoder.inverse_transform([prediction_class_idx])[0]
                    
                    self.process_info[pid]['analyzed'] = True
                    self.stats['processes_analyzed'] += 1
                    
                    if (predicted_class != 'Benign' and 
                        confidence >= self.config['detection_threshold']):
                        
                        self._handle_malware_detection(pid, predicted_class, confidence, api_calls)
                    
                    else:
                        process_name = self.process_info[pid]['name']
                        self.logger.info(f"Processo benigno: {process_name} (PID: {pid}, Conf: {confidence:.3f})")
                    
                    self.detection_results.append({
                        'timestamp': datetime.now(),
                        'pid': pid,
                        'process_name': self.process_info[pid]['name'],
                        'predicted_class': predicted_class,
                        'confidence': confidence,
                        'api_count': len(api_calls),
                        'is_malware': predicted_class != 'Benign'
                    })
                    
                except Exception as e:
                    self.logger.error(f"Erro na análise do processo {pid}: {e}")
                    self.process_info[pid]['analyzed'] = True
                
                finally:
                    self.analyzed_processes.add(pid)
    
    def _handle_malware_detection(self, pid, malware_type, confidence, api_calls):
        """Manipular detecção de malware"""
        process_info = self.process_info[pid]
        process_name = process_info['name']
        exe_path = process_info.get('exe_path', 'Unknown')
        
        self.stats['malware_detected'] += 1
        
        self.logger.critical(
            f"🚨 MALWARE DETECTADO: {process_name} (PID: {pid}) - "
            f"Tipo: {malware_type}, Confiança: {confidence:.3f}"
        )
        
        alert = {
            'timestamp': datetime.now().isoformat(),
            'process_id': pid,
            'process_name': process_name,
            'executable_path': exe_path,
            'malware_type': malware_type,
            'confidence': confidence,
            'api_count': len(api_calls),
            'suspicious_score': process_info.get('suspicious_score', 0),
            'top_apis': list(api_calls)[-20:]
        }
        
        self.alert_queue.put(alert)
        
        if self.config.get('quarantine_detected', False):
            self._quarantine_process(pid)
        
        if self.config.get('auto_terminate', False):
            self._terminate_process(pid)
        
        print(f"\n🚨 ALERTA DE MALWARE:")
        print(f"   Processo: {process_name} (PID: {pid})")
        print(f"   Tipo: {malware_type}")
        print(f"   Confiança: {confidence:.1%}")
        print(f"   APIs coletadas: {len(api_calls)}")
        print(f"   Caminho: {exe_path}")
    
    def _quarantine_process(self, pid):
        """Colocar processo em quarentena"""
        try:
            proc = psutil.Process(pid)
            self.logger.warning(f"Processo {pid} colocado em quarentena")
        except Exception as e:
            self.logger.error(f"Erro ao colocar processo {pid} em quarentena: {e}")
    
    def _terminate_process(self, pid):
        """Terminar processo malicioso"""
        try:
            proc = psutil.Process(pid)
            proc.terminate()
            self.logger.warning(f"Processo malicioso {pid} terminado")
        except Exception as e:
            self.logger.error(f"Erro ao terminar processo {pid}: {e}")
    
    def _alert_sender(self):
        """Thread para enviar alertas via Discord"""
        while self.monitoring:
            try:
                alert = self.alert_queue.get(timeout=5)
                
                if alert and self.config.get('discord_webhook'):
                    self._send_discord_alert(alert)
                
            except queue.Empty:
                continue
            except Exception as e:
                self.logger.error(f"Erro no envio de alertas: {e}")
    
    def _send_discord_alert(self, alert):
        """Enviar alerta via Discord webhook"""
        try:
            webhook_url = self.config['discord_webhook']
            
            embed = {
                "title": "🚨 MALWARE DETECTADO - MODELO DEFENSIVO",
                "color": 0xFF0000,
                "timestamp": alert['timestamp'],
                "fields": [
                    {
                        "name": "Processo",
                        "value": f"`{alert['process_name']}` (PID: {alert['process_id']})",
                        "inline": True
                    },
                    {
                        "name": "Tipo de Malware",
                        "value": f"`{alert['malware_type']}`",
                        "inline": True
                    },
                    {
                        "name": "Confiança",
                        "value": f"{alert['confidence']:.1%}",
                        "inline": True
                    },
                    {
                        "name": "APIs Coletadas",
                        "value": str(alert['api_count']),
                        "inline": True
                    },
                    {
                        "name": "Score Suspeito",
                        "value": str(alert['suspicious_score']),
                        "inline": True
                    },
                    {
                        "name": "Caminho do Executável",
                        "value": f"`{alert['executable_path']}`",
                        "inline": False
                    },
                    {
                        "name": "Principais APIs",
                        "value": f"`{', '.join(alert['top_apis'][:10])}`",
                        "inline": False
                    }
                ],
                "footer": {
                    "text": "Modelo Defensivo - Sistema de Detecção em Tempo Real"
                }
            }
            
            payload = {
                "embeds": [embed],
                "username": "Modelo Defensivo"
            }
            
            response = requests.post(webhook_url, json=payload, timeout=10)
            
            if response.status_code == 204:
                self.stats['alerts_sent'] += 1
                self.logger.info("Alerta enviado via Discord com sucesso")
            else:
                self.logger.error(f"Erro ao enviar alerta Discord: {response.status_code}")
        
        except Exception as e:
            self.logger.error(f"Erro ao enviar alerta Discord: {e}")
    
    def start_monitoring(self):
        """Iniciar monitoramento em tempo real"""
        if self.monitoring:
            print("⚠️ Monitoramento já está ativo")
            return
        
        self.monitoring = True
        self.stats['start_time'] = datetime.now()
        
        print("🚀 Iniciando monitoramento em tempo real...")
        print(f"🎯 Threshold de detecção: {self.config['detection_threshold']:.1%}")
        print(f"⏱️ Intervalo de análise: {self.config['analysis_interval']} segundos")
        print(f"📊 Mínimo de API calls: {self.config['min_api_calls']}")
        
        if self.config.get('discord_webhook'):
            print(f"📢 Alertas Discord: Ativados")
        else:
            print(f"📢 Alertas Discord: Desativados")
        
        print("\n🛡️ MONITORAMENTO ATIVO - Pressione Ctrl+C para parar\n")
        
        self.detection_thread = threading.Thread(target=self._monitor_system_processes)
        self.detection_thread.daemon = True
        self.detection_thread.start()
        
        alert_thread = threading.Thread(target=self._alert_sender)
        alert_thread.daemon = True
        alert_thread.start()
        
        try:
            while self.monitoring:
                time.sleep(30)
                self._print_status()
        
        except KeyboardInterrupt:
            self.stop_monitoring()
    
    def _print_status(self):
        """Imprimir status do monitoramento"""
        uptime = datetime.now() - self.stats['start_time']
        active_processes = len(self.process_info)
        
        print(f"📊 Status: {uptime} | "
              f"Processos ativos: {active_processes} | "
              f"Analisados: {self.stats['processes_analyzed']} | "
              f"Malware: {self.stats['malware_detected']} | "
              f"Alertas: {self.stats['alerts_sent']}")
    
    def stop_monitoring(self):
        """Parar monitoramento"""
        if not self.monitoring:
            return
        
        print("\n🛑 Parando monitoramento...")
        self.monitoring = False
        
        if self.detection_thread:
            self.detection_thread.join(timeout=5)
        
        total_time = datetime.now() - self.stats['start_time']
        
        print(f"\n📊 ESTATÍSTICAS FINAIS:")
        print(f"   Tempo de execução: {total_time}")
        print(f"   Processos analisados: {self.stats['processes_analyzed']}")
        print(f"   Malware detectado: {self.stats['malware_detected']}")
        print(f"   Alertas enviados: {self.stats['alerts_sent']}")
        print(f"   Taxa de detecção: {self.stats['malware_detected']}/{self.stats['processes_analyzed']}")
        
        self.logger.info("Monitoramento finalizado")

def main():
    """Função principal para executar o detector em tempo real"""
    print("🛡️ SISTEMA DE DETECÇÃO EM TEMPO REAL - MODELO DEFENSIVO")
    print("=" * 65)
    print("Detector de malware polimórfico usando Random Forest")
    print("Integração com Discord para alertas em tempo real")
    print()
    
    model_files = {
        'model': '../ModelTraining/trained_models/defensive_model_polymorphic.joblib',
        'vectorizer': '../ModelTraining/trained_models/defensive_model_polymorphic_vectorizer.joblib',
        'encoder': '../ModelTraining/trained_models/defensive_model_polymorphic_encoder.joblib',
        'config': 'detection_config.json'
    }
    
    missing_files = []
    for name, path in model_files.items():
        if name != 'config' and not Path(path).exists():
            missing_files.append(f"{name}: {path}")
    
    if missing_files:
        print("❌ Arquivos do modelo não encontrados:")
        for file in missing_files:
            print(f"   - {file}")
        print("\n💡 Execute primeiro o treinamento do modelo.")
        return
    
    try:
        detector = RealtimeMalwareDetector(
            model_path=model_files['model'],
            vectorizer_path=model_files['vectorizer'],
            encoder_path=model_files['encoder'],
            config_path=model_files['config'] if Path(model_files['config']).exists() else None
        )
        
        detector.start_monitoring()
        
    except KeyboardInterrupt:
        print("\n🛑 Programa interrompido pelo usuário")
    except Exception as e:
        print(f"❌ Erro no detector: {e}")
        logging.error(f"Erro no detector: {e}")

if __name__ == "__main__":
    main()