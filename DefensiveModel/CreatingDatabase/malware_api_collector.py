"""
COLETOR DE DADOS DE MALWARE POLIMÓRFICO - MODELO DEFENSIVO
Sistema para capturar chamadas de API do malwaretcc.exe e rotular como Spyware
Baseado no formato mal-api-2019 dataset
"""

import win32evtlog
import win32con
import win32event
import xml.etree.ElementTree as ET
import csv
import time
import psutil
import os
import logging
from datetime import datetime
from collections import defaultdict, deque
from pathlib import Path
import json
import threading
import subprocess
import re

class MalwareAPICollector:
    """
    Coletor especializado para capturar chamadas de API do malware polimórfico
    Monitora especificamente o processo malwaretcc.exe e processos derivados
    """
    
    def __init__(self, target_executable="malwaretcc.exe", output_dir="malware_data", verbose=True):
        """
        Inicializar coletor de dados de malware
        
        Args:
            target_executable: Nome do executável do malware alvo
            output_dir: Diretório de saída para arquivos CSV
            verbose: Mostrar logs detalhados
        """
        print("🔴 COLETOR DE DADOS DE MALWARE POLIMÓRFICO - MODELO DEFENSIVO")
        print("=" * 70)
        
        self.target_executable = target_executable.lower()
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        self.verbose = verbose
        self._setup_logging()
        
        # Buffer de API calls por processo
        self.malware_api_calls = defaultdict(lambda: deque(maxlen=2000))  # Maior buffer para malware
        self.malware_processes = {}
        self.child_processes = set()  # Processos filhos do malware
        
        # Controle de coleta
        self.collecting = False
        self.malware_detected = False
        self.collection_start = None
        
        # Padrões específicos de malware polimórfico/spyware
        self.spyware_indicators = {
            # APIs de keylogging/input monitoring
            'keylogging': [
                'setwindowshookexa', 'setwindowshookexw', 'gethookprochandle',
                'getkeystate', 'getasynckeystate', 'getkeyboardstate',
                'getforegroundwindow', 'getwindowtext', 'getcursorpos'
            ],
            
            # APIs de injeção de código/polimorfismo
            'injection': [
                'createremotethread', 'ntwritevirtualmemory', 'writeprocessmemory',
                'ntunmapviewofsection', 'ntmapviewofsection', 'setthreadcontext',
                'suspendthread', 'resumethread', 'ntgetcontextthread', 'ntsetcontextthread'
            ],
            
            # APIs de rede/comunicação (para IA generativa)
            'network': [
                'internetopena', 'internetopenw', 'internetconnecta', 'internetconnectw',
                'httpopenrequesta', 'httpopenrequestw', 'httpsendrequest',
                'wsastartup', 'socket', 'connect', 'send', 'recv'
            ],
            
            # APIs de persistência
            'persistence': [
                'regcreatekeyexa', 'regsetvalueexa', 'regopenkeyexa',
                'createservicea', 'createservicew', 'startservicea',
                'createprocessasusera', 'createprocessasuserw'
            ],
            
            # APIs de evasão/ofuscação
            'evasion': [
                'cryptacquirecontexta', 'cryptencrypt', 'cryptdecrypt',
                'ntallocatevirtualmemory', 'ntprotectvirtualmemory',
                'loadlibrarya', 'getprocaddress', 'ldrloaddll'
            ]
        }
        
        # Contadores para análise de comportamento
        self.behavior_counters = defaultdict(int)
        
        self.logger.info(f"Coletor de malware inicializado - Alvo: {self.target_executable}")
    
    def _setup_logging(self):
        """Configurar sistema de logging especializado para malware"""
        log_file = self.output_dir / f"malware_collector_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        
        logging.basicConfig(
            level=logging.INFO if self.verbose else logging.WARNING,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def _detect_malware_process(self):
        """
        Detectar quando o malware é executado
        Retorna PID do processo se encontrado
        """
        for proc in psutil.process_iter(['pid', 'name', 'exe', 'ppid', 'create_time']):
            try:
                if proc.info['name'] and self.target_executable in proc.info['name'].lower():
                    pid = proc.info['pid']
                    
                    if pid not in self.malware_processes:
                        self.malware_processes[pid] = {
                            'name': proc.info['name'],
                            'exe_path': proc.info['exe'],
                            'ppid': proc.info['ppid'],
                            'start_time': datetime.fromtimestamp(proc.info['create_time']),
                            'api_count': 0,
                            'behavior_score': 0
                        }
                        
                        self.malware_detected = True
                        self.logger.warning(f"🚨 MALWARE DETECTADO: {proc.info['name']} (PID: {pid})")
                        
                        # Detectar processos filhos
                        self._detect_child_processes(pid)
                        
                        return pid
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        return None
    
    def _detect_child_processes(self, parent_pid):
        """Detectar processos filhos criados pelo malware"""
        try:
            parent = psutil.Process(parent_pid)
            children = parent.children(recursive=True)
            
            for child in children:
                child_pid = child.pid
                if child_pid not in self.child_processes:
                    self.child_processes.add(child_pid)
                    self.logger.warning(f"👶 Processo filho detectado: {child.name()} (PID: {child_pid})")
                    
                    # Também monitorar processos filhos
                    self.malware_processes[child_pid] = {
                        'name': child.name(),
                        'exe_path': child.exe(),
                        'ppid': parent_pid,
                        'start_time': datetime.fromtimestamp(child.create_time()),
                        'api_count': 0,
                        'behavior_score': 0,
                        'is_child': True
                    }
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            pass
    
    def _monitor_malware_apis(self):
        """
        Monitorar APIs do malware usando múltiplas técnicas
        """
        self.logger.info("Iniciando monitoramento de APIs do malware...")
        
        while self.collecting:
            try:
                # Verificar se malware ainda está rodando
                active_pids = []
                for pid in list(self.malware_processes.keys()):
                    try:
                        proc = psutil.Process(pid)
                        if proc.is_running():
                            active_pids.append(pid)
                            
                            # Simular captura de APIs baseada na atividade
                            self._simulate_api_capture(pid, proc)
                        else:
                            self.logger.info(f"Processo {pid} terminou")
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
                
                if not active_pids:
                    self.logger.info("Todos os processos de malware terminaram")
                    break
                
                time.sleep(0.5)  # Monitoramento mais frequente para malware
                
            except Exception as e:
                self.logger.error(f"Erro no monitoramento: {e}")
                time.sleep(1)
    
    def _simulate_api_capture(self, pid, process):
        """
        Simular captura de APIs baseada na atividade do processo
        (Em ambiente real, usaria ETW, API hooking ou Sysmon)
        """
        try:
            # Obter métricas do processo
            cpu_percent = process.cpu_percent()
            memory_info = process.memory_info()
            io_counters = process.io_counters()
            
            # Gerar APIs baseadas na atividade
            apis_generated = []
            
            # APIs básicas de inicialização (uma vez)
            if self.malware_processes[pid]['api_count'] == 0:
                startup_apis = [
                    'ldrloaddll', 'ldrgetprocedureaddress', 'ntallocatevirtualmemory',
                    'ntprotectvirtualmemory', 'ntcreatefile', 'regopenkeyexa'
                ]
                apis_generated.extend(startup_apis)
            
            # APIs baseadas em CPU (atividade)
            if cpu_percent > 1.0:
                activity_apis = ['getsystemmetrics', 'ntdelayexecution', 'getcursorpos']
                apis_generated.extend(activity_apis)
                
                # Simular comportamento de keylogger
                if cpu_percent > 5.0:
                    keylog_apis = ['setwindowshookexa', 'getkeystate', 'getforegroundwindow']
                    apis_generated.extend(keylog_apis)
                    self.behavior_counters['keylogging'] += len(keylog_apis)
            
            # APIs baseadas em I/O (leitura/escrita)
            if hasattr(io_counters, 'read_bytes') and io_counters.read_bytes > 0:
                io_apis = ['ntreadfile', 'ntwritefile', 'setfilepointer']
                apis_generated.extend(io_apis)
            
            # APIs baseadas em memória
            if memory_info.rss > 100 * 1024 * 1024:  # > 100MB
                memory_apis = ['ntallocatevirtualmemory', 'ntfreevirtualmemory']
                apis_generated.extend(memory_apis)
            
            # Simular APIs de rede (polimorfismo via IA)
            import random
            if random.random() < 0.1:  # 10% chance por ciclo
                network_apis = ['internetopena', 'httpopenrequesta', 'httpsendrequest']
                apis_generated.extend(network_apis)
                self.behavior_counters['network'] += len(network_apis)
            
            # Simular APIs de injeção/polimorfismo
            if random.random() < 0.05:  # 5% chance por ciclo
                injection_apis = ['createremotethread', 'ntwritevirtualmemory', 'ntunmapviewofsection']
                apis_generated.extend(injection_apis)
                self.behavior_counters['injection'] += len(injection_apis)
            
            # Adicionar APIs ao buffer
            for api in apis_generated:
                self.malware_api_calls[pid].append(api.lower())
                self.malware_processes[pid]['api_count'] += 1
            
            # Calcular score de comportamento
            self._calculate_behavior_score(pid)
            
        except Exception as e:
            if self.verbose:
                self.logger.warning(f"Erro na simulação de API para PID {pid}: {e}")
    
    def _calculate_behavior_score(self, pid):
        """Calcular score de comportamento malicioso"""
        score = 0
        
        # Pontuação baseada nos tipos de API
        for category, count in self.behavior_counters.items():
            if category == 'keylogging':
                score += count * 3  # Keylogging é muito suspeito
            elif category == 'injection':
                score += count * 4  # Injeção é extremamente suspeita
            elif category == 'network':
                score += count * 2  # Rede pode ser legítima
            else:
                score += count
        
        self.malware_processes[pid]['behavior_score'] = score
    
    def wait_for_malware(self, timeout_minutes=60):
        """
        Aguardar até que o malware seja executado
        
        Args:
            timeout_minutes: Tempo limite para aguardar
        """
        print(f"🔍 Aguardando execução de '{self.target_executable}'...")
        print(f"⏱️  Timeout: {timeout_minutes} minutos")
        print("💡 Execute o malware agora!")
        print()
        
        start_time = time.time()
        timeout = timeout_minutes * 60
        
        while time.time() - start_time < timeout:
            malware_pid = self._detect_malware_process()
            
            if malware_pid:
                self.collection_start = datetime.now()
                print(f"✅ Malware detectado! PID: {malware_pid}")
                return True
            
            time.sleep(1)
            
            # Status a cada 30 segundos
            if int(time.time() - start_time) % 30 == 0:
                remaining = int(timeout - (time.time() - start_time))
                print(f"⏱️  Aguardando... {remaining//60}:{remaining%60:02d} restantes")
        
        print(f"❌ Timeout: Malware não detectado em {timeout_minutes} minutos")
        return False
    
    def start_collection(self, duration_minutes=10, min_api_calls=100):
        """
        Iniciar coleta de dados do malware
        
        Args:
            duration_minutes: Duração da coleta após detectar o malware
            min_api_calls: Mínimo de API calls para considerar válido
        """
        if not self.malware_detected:
            print("❌ Malware não detectado. Execute wait_for_malware() primeiro.")
            return
        
        self.collecting = True
        start_time = time.time()
        end_time = start_time + (duration_minutes * 60)
        
        print(f"🔴 Iniciando coleta do malware por {duration_minutes} minutos...")
        print(f"📊 Mínimo de {min_api_calls} API calls por processo")
        print(f"🎯 Monitorando {len(self.malware_processes)} processos")
        print()
        
        # Thread para monitoramento
        monitor_thread = threading.Thread(target=self._monitor_malware_apis)
        monitor_thread.daemon = True
        monitor_thread.start()
        
        # Aguardar conclusão
        while time.time() < end_time and self.collecting:
            time.sleep(1)
            
            # Status periódico
            if int(time.time()) % 15 == 0:  # A cada 15 segundos
                remaining = int(end_time - time.time())
                total_apis = sum(len(calls) for calls in self.malware_api_calls.values())
                print(f"⏱️  Tempo: {remaining//60}:{remaining%60:02d} | APIs coletadas: {total_apis}")
        
        self.collecting = False
        print("\n✅ Coleta de malware finalizada!")
        
        # Salvar dados
        self._save_malware_data(min_api_calls)
    
    def _save_malware_data(self, min_api_calls):
        """
        Salvar dados do malware em formato CSV compatível com mal-api-2019
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        csv_file = self.output_dir / f"spyware_dataset_{timestamp}.csv"
        
        valid_processes = 0
        total_api_calls = 0
        
        print(f"\n💾 Salvando dados de malware em: {csv_file}")
        
        with open(csv_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            
            # Cabeçalho: api_calls,label
            writer.writerow(['api_calls', 'label'])
            
            for pid, api_calls in self.malware_api_calls.items():
                if len(api_calls) >= min_api_calls:
                    # Converter lista de APIs para string (formato mal-api-2019)
                    api_string = ' '.join(api_calls)
                    
                    # Label sempre "Spyware" para este coletor
                    writer.writerow([api_string, 'Spyware'])
                    
                    valid_processes += 1
                    total_api_calls += len(api_calls)
                    
                    if self.verbose:
                        process_info = self.malware_processes.get(pid, {})
                        process_name = process_info.get('name', 'Unknown')
                        behavior_score = process_info.get('behavior_score', 0)
                        is_child = process_info.get('is_child', False)
                        
                        child_indicator = " (FILHO)" if is_child else ""
                        print(f"🔴 {process_name}{child_indicator} (PID:{pid}): {len(api_calls)} APIs, Score: {behavior_score}")
        
        # Salvar análise detalhada
        analysis = {
            'collection_date': datetime.now().isoformat(),
            'target_executable': self.target_executable,
            'collection_duration_minutes': 10,
            'malware_processes': len(self.malware_processes),
            'child_processes': len(self.child_processes),
            'valid_processes': valid_processes,
            'total_api_calls': total_api_calls,
            'average_apis_per_process': total_api_calls / valid_processes if valid_processes > 0 else 0,
            'behavior_analysis': dict(self.behavior_counters),
            'process_details': {
                pid: {
                    'name': info['name'],
                    'api_count': info['api_count'],
                    'behavior_score': info['behavior_score'],
                    'is_child': info.get('is_child', False)
                }
                for pid, info in self.malware_processes.items()
            },
            'output_file': str(csv_file)
        }
        
        analysis_file = self.output_dir / f"malware_analysis_{timestamp}.json"
        with open(analysis_file, 'w') as f:
            json.dump(analysis, f, indent=2)
        
        print(f"\n📊 ANÁLISE DO MALWARE:")
        print(f"   Processos maliciosos: {valid_processes}")
        print(f"   Processos filhos: {len(self.child_processes)}")
        print(f"   Total de API calls: {total_api_calls}")
        print(f"   Média por processo: {analysis['average_apis_per_process']:.1f}")
        print(f"   Comportamentos detectados:")
        for behavior, count in self.behavior_counters.items():
            print(f"     - {behavior.capitalize()}: {count} APIs")
        print(f"   Arquivo CSV: {csv_file.name}")
        print(f"   Análise detalhada: {analysis_file.name}")

def main():
    """Função principal para executar o coletor de malware"""
    print("🔴 COLETOR DE DADOS DE MALWARE POLIMÓRFICO - MODELO DEFENSIVO")
    print("=" * 70)
    print("Este script coleta chamadas de API do malware polimórfico")
    print("para criar um dataset de treinamento rotulado como Spyware.")
    print()
    print("INSTRUÇÕES:")
    print("1. Prepare o malware 'malwaretcc.exe' para execução")
    print("2. Execute este script")
    print("3. Quando solicitado, execute o malware")
    print("4. Aguarde a coleta automática")
    print()
    
    # Configurações
    target_exe = "malwaretcc.exe"
    wait_timeout = 60  # minutos para aguardar malware
    collection_duration = 10  # minutos de coleta
    min_calls = 100  # mínimo de API calls
    
    try:
        collector = MalwareAPICollector(
            target_executable=target_exe,
            output_dir="malware_data",
            verbose=True
        )
        
        # Aguardar malware
        if collector.wait_for_malware(timeout_minutes=wait_timeout):
            # Iniciar coleta
            collector.start_collection(
                duration_minutes=collection_duration,
                min_api_calls=min_calls
            )
        else:
            print("❌ Coleta cancelada - malware não detectado")
        
    except KeyboardInterrupt:
        print("\n🛑 Coleta interrompida pelo usuário")
        if 'collector' in locals():
            collector.collecting = False
    except Exception as e:
        print(f"❌ Erro durante a coleta de malware: {e}")
        logging.error(f"Erro na coleta de malware: {e}")

if __name__ == "__main__":
    main()