"""
COLETOR DE DADOS DE MALWARE POLIM√ìRFICO - MODELO DEFENSIVO
Sistema para capturar chamadas de API do malwaretcc.exe e rotular como Spyware
Baseado no formato mal-api-2019 dataset
"""

import win32evtlog
import win32con
import win32event
import xml.etree.ElementTree as ET
import csv
import time
import psutil
import os
import logging
from datetime import datetime
from collections import defaultdict, deque
from pathlib import Path
import json
import threading
import subprocess
import re

class MalwareAPICollector:
    """
    Coletor especializado para capturar chamadas de API do malware polim√≥rfico
    Monitora especificamente o processo malwaretcc.exe e processos derivados
    """
    
    def __init__(self, target_executable="malwaretcc.exe", output_dir="malware_data", verbose=True):
        """
        Inicializar coletor de dados de malware
        
        Args:
            target_executable: Nome do execut√°vel do malware alvo
            output_dir: Diret√≥rio de sa√≠da para arquivos CSV
            verbose: Mostrar logs detalhados
        """
        print("üî¥ COLETOR DE DADOS DE MALWARE POLIM√ìRFICO - MODELO DEFENSIVO")
        print("=" * 70)
        
        self.target_executable = target_executable.lower()
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        self.verbose = verbose
        self._setup_logging()
        
        # Buffer de API calls por processo
        self.malware_api_calls = defaultdict(lambda: deque(maxlen=2000))  # Maior buffer para malware
        self.malware_processes = {}
        self.child_processes = set()  # Processos filhos do malware
        
        # Controle de coleta
        self.collecting = False
        self.malware_detected = False
        self.collection_start = None
        
        # Padr√µes espec√≠ficos de malware polim√≥rfico/spyware
        self.spyware_indicators = {
            # APIs de keylogging/input monitoring
            'keylogging': [
                'setwindowshookexa', 'setwindowshookexw', 'gethookprochandle',
                'getkeystate', 'getasynckeystate', 'getkeyboardstate',
                'getforegroundwindow', 'getwindowtext', 'getcursorpos'
            ],
            
            # APIs de inje√ß√£o de c√≥digo/polimorfismo
            'injection': [
                'createremotethread', 'ntwritevirtualmemory', 'writeprocessmemory',
                'ntunmapviewofsection', 'ntmapviewofsection', 'setthreadcontext',
                'suspendthread', 'resumethread', 'ntgetcontextthread', 'ntsetcontextthread'
            ],
            
            # APIs de rede/comunica√ß√£o (para IA generativa)
            'network': [
                'internetopena', 'internetopenw', 'internetconnecta', 'internetconnectw',
                'httpopenrequesta', 'httpopenrequestw', 'httpsendrequest',
                'wsastartup', 'socket', 'connect', 'send', 'recv'
            ],
            
            # APIs de persist√™ncia
            'persistence': [
                'regcreatekeyexa', 'regsetvalueexa', 'regopenkeyexa',
                'createservicea', 'createservicew', 'startservicea',
                'createprocessasusera', 'createprocessasuserw'
            ],
            
            # APIs de evas√£o/ofusca√ß√£o
            'evasion': [
                'cryptacquirecontexta', 'cryptencrypt', 'cryptdecrypt',
                'ntallocatevirtualmemory', 'ntprotectvirtualmemory',
                'loadlibrarya', 'getprocaddress', 'ldrloaddll'
            ]
        }
        
        # Contadores para an√°lise de comportamento
        self.behavior_counters = defaultdict(int)
        
        self.logger.info(f"Coletor de malware inicializado - Alvo: {self.target_executable}")
    
    def _setup_logging(self):
        """Configurar sistema de logging especializado para malware"""
        log_file = self.output_dir / f"malware_collector_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        
        logging.basicConfig(
            level=logging.INFO if self.verbose else logging.WARNING,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def _detect_malware_process(self):
        """
        Detectar quando o malware √© executado
        Retorna PID do processo se encontrado
        """
        for proc in psutil.process_iter(['pid', 'name', 'exe', 'ppid', 'create_time']):
            try:
                if proc.info['name'] and self.target_executable in proc.info['name'].lower():
                    pid = proc.info['pid']
                    
                    if pid not in self.malware_processes:
                        self.malware_processes[pid] = {
                            'name': proc.info['name'],
                            'exe_path': proc.info['exe'],
                            'ppid': proc.info['ppid'],
                            'start_time': datetime.fromtimestamp(proc.info['create_time']),
                            'api_count': 0,
                            'behavior_score': 0
                        }
                        
                        self.malware_detected = True
                        self.logger.warning(f"üö® MALWARE DETECTADO: {proc.info['name']} (PID: {pid})")
                        
                        # Detectar processos filhos
                        self._detect_child_processes(pid)
                        
                        return pid
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        return None
    
    def _detect_child_processes(self, parent_pid):
        """Detectar processos filhos criados pelo malware"""
        try:
            parent = psutil.Process(parent_pid)
            children = parent.children(recursive=True)
            
            for child in children:
                child_pid = child.pid
                if child_pid not in self.child_processes:
                    self.child_processes.add(child_pid)
                    self.logger.warning(f"üë∂ Processo filho detectado: {child.name()} (PID: {child_pid})")
                    
                    # Tamb√©m monitorar processos filhos
                    self.malware_processes[child_pid] = {
                        'name': child.name(),
                        'exe_path': child.exe(),
                        'ppid': parent_pid,
                        'start_time': datetime.fromtimestamp(child.create_time()),
                        'api_count': 0,
                        'behavior_score': 0,
                        'is_child': True
                    }
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            pass
    
    def _monitor_malware_apis(self):
        """
        Monitorar APIs do malware usando m√∫ltiplas t√©cnicas
        """
        self.logger.info("Iniciando monitoramento de APIs do malware...")
        
        while self.collecting:
            try:
                # Verificar se malware ainda est√° rodando
                active_pids = []
                for pid in list(self.malware_processes.keys()):
                    try:
                        proc = psutil.Process(pid)
                        if proc.is_running():
                            active_pids.append(pid)
                            
                            # Simular captura de APIs baseada na atividade
                            self._simulate_api_capture(pid, proc)
                        else:
                            self.logger.info(f"Processo {pid} terminou")
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
                
                if not active_pids:
                    self.logger.info("Todos os processos de malware terminaram")
                    break
                
                time.sleep(0.5)  # Monitoramento mais frequente para malware
                
            except Exception as e:
                self.logger.error(f"Erro no monitoramento: {e}")
                time.sleep(1)
    
    def _simulate_api_capture(self, pid, process):
        """
        Simular captura de APIs baseada na atividade do processo
        (Em ambiente real, usaria ETW, API hooking ou Sysmon)
        """
        try:
            # Obter m√©tricas do processo
            cpu_percent = process.cpu_percent()
            memory_info = process.memory_info()
            io_counters = process.io_counters()
            
            # Gerar APIs baseadas na atividade
            apis_generated = []
            
            # APIs b√°sicas de inicializa√ß√£o (uma vez)
            if self.malware_processes[pid]['api_count'] == 0:
                startup_apis = [
                    'ldrloaddll', 'ldrgetprocedureaddress', 'ntallocatevirtualmemory',
                    'ntprotectvirtualmemory', 'ntcreatefile', 'regopenkeyexa'
                ]
                apis_generated.extend(startup_apis)
            
            # APIs baseadas em CPU (atividade)
            if cpu_percent > 1.0:
                activity_apis = ['getsystemmetrics', 'ntdelayexecution', 'getcursorpos']
                apis_generated.extend(activity_apis)
                
                # Simular comportamento de keylogger
                if cpu_percent > 5.0:
                    keylog_apis = ['setwindowshookexa', 'getkeystate', 'getforegroundwindow']
                    apis_generated.extend(keylog_apis)
                    self.behavior_counters['keylogging'] += len(keylog_apis)
            
            # APIs baseadas em I/O (leitura/escrita)
            if hasattr(io_counters, 'read_bytes') and io_counters.read_bytes > 0:
                io_apis = ['ntreadfile', 'ntwritefile', 'setfilepointer']
                apis_generated.extend(io_apis)
            
            # APIs baseadas em mem√≥ria
            if memory_info.rss > 100 * 1024 * 1024:  # > 100MB
                memory_apis = ['ntallocatevirtualmemory', 'ntfreevirtualmemory']
                apis_generated.extend(memory_apis)
            
            # Simular APIs de rede (polimorfismo via IA)
            import random
            if random.random() < 0.1:  # 10% chance por ciclo
                network_apis = ['internetopena', 'httpopenrequesta', 'httpsendrequest']
                apis_generated.extend(network_apis)
                self.behavior_counters['network'] += len(network_apis)
            
            # Simular APIs de inje√ß√£o/polimorfismo
            if random.random() < 0.05:  # 5% chance por ciclo
                injection_apis = ['createremotethread', 'ntwritevirtualmemory', 'ntunmapviewofsection']
                apis_generated.extend(injection_apis)
                self.behavior_counters['injection'] += len(injection_apis)
            
            # Adicionar APIs ao buffer
            for api in apis_generated:
                self.malware_api_calls[pid].append(api.lower())
                self.malware_processes[pid]['api_count'] += 1
            
            # Calcular score de comportamento
            self._calculate_behavior_score(pid)
            
        except Exception as e:
            if self.verbose:
                self.logger.warning(f"Erro na simula√ß√£o de API para PID {pid}: {e}")
    
    def _calculate_behavior_score(self, pid):
        """Calcular score de comportamento malicioso"""
        score = 0
        
        # Pontua√ß√£o baseada nos tipos de API
        for category, count in self.behavior_counters.items():
            if category == 'keylogging':
                score += count * 3  # Keylogging √© muito suspeito
            elif category == 'injection':
                score += count * 4  # Inje√ß√£o √© extremamente suspeita
            elif category == 'network':
                score += count * 2  # Rede pode ser leg√≠tima
            else:
                score += count
        
        self.malware_processes[pid]['behavior_score'] = score
    
    def wait_for_malware(self, timeout_minutes=60):
        """
        Aguardar at√© que o malware seja executado
        
        Args:
            timeout_minutes: Tempo limite para aguardar
        """
        print(f"üîç Aguardando execu√ß√£o de '{self.target_executable}'...")
        print(f"‚è±Ô∏è  Timeout: {timeout_minutes} minutos")
        print("üí° Execute o malware agora!")
        print()
        
        start_time = time.time()
        timeout = timeout_minutes * 60
        
        while time.time() - start_time < timeout:
            malware_pid = self._detect_malware_process()
            
            if malware_pid:
                self.collection_start = datetime.now()
                print(f"‚úÖ Malware detectado! PID: {malware_pid}")
                return True
            
            time.sleep(1)
            
            # Status a cada 30 segundos
            if int(time.time() - start_time) % 30 == 0:
                remaining = int(timeout - (time.time() - start_time))
                print(f"‚è±Ô∏è  Aguardando... {remaining//60}:{remaining%60:02d} restantes")
        
        print(f"‚ùå Timeout: Malware n√£o detectado em {timeout_minutes} minutos")
        return False
    
    def start_collection(self, duration_minutes=10, min_api_calls=100):
        """
        Iniciar coleta de dados do malware
        
        Args:
            duration_minutes: Dura√ß√£o da coleta ap√≥s detectar o malware
            min_api_calls: M√≠nimo de API calls para considerar v√°lido
        """
        if not self.malware_detected:
            print("‚ùå Malware n√£o detectado. Execute wait_for_malware() primeiro.")
            return
        
        self.collecting = True
        start_time = time.time()
        end_time = start_time + (duration_minutes * 60)
        
        print(f"üî¥ Iniciando coleta do malware por {duration_minutes} minutos...")
        print(f"üìä M√≠nimo de {min_api_calls} API calls por processo")
        print(f"üéØ Monitorando {len(self.malware_processes)} processos")
        print()
        
        # Thread para monitoramento
        monitor_thread = threading.Thread(target=self._monitor_malware_apis)
        monitor_thread.daemon = True
        monitor_thread.start()
        
        # Aguardar conclus√£o
        while time.time() < end_time and self.collecting:
            time.sleep(1)
            
            # Status peri√≥dico
            if int(time.time()) % 15 == 0:  # A cada 15 segundos
                remaining = int(end_time - time.time())
                total_apis = sum(len(calls) for calls in self.malware_api_calls.values())
                print(f"‚è±Ô∏è  Tempo: {remaining//60}:{remaining%60:02d} | APIs coletadas: {total_apis}")
        
        self.collecting = False
        print("\n‚úÖ Coleta de malware finalizada!")
        
        # Salvar dados
        self._save_malware_data(min_api_calls)
    
    def _save_malware_data(self, min_api_calls):
        """
        Salvar dados do malware em formato CSV compat√≠vel com mal-api-2019
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        csv_file = self.output_dir / f"spyware_dataset_{timestamp}.csv"
        
        valid_processes = 0
        total_api_calls = 0
        
        print(f"\nüíæ Salvando dados de malware em: {csv_file}")
        
        with open(csv_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            
            # Cabe√ßalho: api_calls,label
            writer.writerow(['api_calls', 'label'])
            
            for pid, api_calls in self.malware_api_calls.items():
                if len(api_calls) >= min_api_calls:
                    # Converter lista de APIs para string (formato mal-api-2019)
                    api_string = ' '.join(api_calls)
                    
                    # Label sempre "Spyware" para este coletor
                    writer.writerow([api_string, 'Spyware'])
                    
                    valid_processes += 1
                    total_api_calls += len(api_calls)
                    
                    if self.verbose:
                        process_info = self.malware_processes.get(pid, {})
                        process_name = process_info.get('name', 'Unknown')
                        behavior_score = process_info.get('behavior_score', 0)
                        is_child = process_info.get('is_child', False)
                        
                        child_indicator = " (FILHO)" if is_child else ""
                        print(f"üî¥ {process_name}{child_indicator} (PID:{pid}): {len(api_calls)} APIs, Score: {behavior_score}")
        
        # Salvar an√°lise detalhada
        analysis = {
            'collection_date': datetime.now().isoformat(),
            'target_executable': self.target_executable,
            'collection_duration_minutes': 10,
            'malware_processes': len(self.malware_processes),
            'child_processes': len(self.child_processes),
            'valid_processes': valid_processes,
            'total_api_calls': total_api_calls,
            'average_apis_per_process': total_api_calls / valid_processes if valid_processes > 0 else 0,
            'behavior_analysis': dict(self.behavior_counters),
            'process_details': {
                pid: {
                    'name': info['name'],
                    'api_count': info['api_count'],
                    'behavior_score': info['behavior_score'],
                    'is_child': info.get('is_child', False)
                }
                for pid, info in self.malware_processes.items()
            },
            'output_file': str(csv_file)
        }
        
        analysis_file = self.output_dir / f"malware_analysis_{timestamp}.json"
        with open(analysis_file, 'w') as f:
            json.dump(analysis, f, indent=2)
        
        print(f"\nüìä AN√ÅLISE DO MALWARE:")
        print(f"   Processos maliciosos: {valid_processes}")
        print(f"   Processos filhos: {len(self.child_processes)}")
        print(f"   Total de API calls: {total_api_calls}")
        print(f"   M√©dia por processo: {analysis['average_apis_per_process']:.1f}")
        print(f"   Comportamentos detectados:")
        for behavior, count in self.behavior_counters.items():
            print(f"     - {behavior.capitalize()}: {count} APIs")
        print(f"   Arquivo CSV: {csv_file.name}")
        print(f"   An√°lise detalhada: {analysis_file.name}")

def main():
    """Fun√ß√£o principal para executar o coletor de malware"""
    print("üî¥ COLETOR DE DADOS DE MALWARE POLIM√ìRFICO - MODELO DEFENSIVO")
    print("=" * 70)
    print("Este script coleta chamadas de API do malware polim√≥rfico")
    print("para criar um dataset de treinamento rotulado como Spyware.")
    print()
    print("INSTRU√á√ïES:")
    print("1. Prepare o malware 'malwaretcc.exe' para execu√ß√£o")
    print("2. Execute este script")
    print("3. Quando solicitado, execute o malware")
    print("4. Aguarde a coleta autom√°tica")
    print()
    
    # Configura√ß√µes
    target_exe = "malwaretcc.exe"
    wait_timeout = 60  # minutos para aguardar malware
    collection_duration = 10  # minutos de coleta
    min_calls = 100  # m√≠nimo de API calls
    
    try:
        collector = MalwareAPICollector(
            target_executable=target_exe,
            output_dir="malware_data",
            verbose=True
        )
        
        # Aguardar malware
        if collector.wait_for_malware(timeout_minutes=wait_timeout):
            # Iniciar coleta
            collector.start_collection(
                duration_minutes=collection_duration,
                min_api_calls=min_calls
            )
        else:
            print("‚ùå Coleta cancelada - malware n√£o detectado")
        
    except KeyboardInterrupt:
        print("\nüõë Coleta interrompida pelo usu√°rio")
        if 'collector' in locals():
            collector.collecting = False
    except Exception as e:
        print(f"‚ùå Erro durante a coleta de malware: {e}")
        logging.error(f"Erro na coleta de malware: {e}")

if __name__ == "__main__":
    main()